# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'app.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


# all the imports of libraries or codes used
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from PyQt5 import QtCore, QtGui, QtWidgets
from pyvis.network import Network
import networkx as nx
import Graph
import Logic



class Ui_MainWindow(object):
    # setting up the UI components
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1104, 1129)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setAutoFillBackground(False)
        self.centralwidget.setStyleSheet("background:rgb(249, 170, 51);\n")
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout(self.centralwidget)
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.verticalLayout_8 = QtWidgets.QVBoxLayout()
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_2.setFont(font)
        self.label_2.setStyleSheet("color: #FFFFFF")
        self.label_2.setAlignment(QtCore.Qt.AlignCenter)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_8.addWidget(self.label_2)
        self.comboBox_2 = QtWidgets.QComboBox(self.centralwidget)
        # the style sheet of the first combobox
        self.comboBox_2.setStyleSheet("QComboBox QAbstractItemView" "{"
    "font:32px;"
        "color: #FFFFFF"
    
"}"
                "QComboBox:hover {\n"
"     color: #FFFFFF; background-color: rgb(0,143,150);\n"
"}\n"                                 
"QComboBox:pressed {    \n"
"   color: #FFFFFF;  background-color: rgb(0,143,150);\n"
"}\n")
        self.comboBox_2.setObjectName("comboBox_2")
        self.verticalLayout_8.addWidget(self.comboBox_2)
        self.horizontalLayout_7.addLayout(self.verticalLayout_8)
        self.verticalLayout_7 = QtWidgets.QVBoxLayout()
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label.setFont(font)
        self.label.setStyleSheet("color: #FFFFFF")
        self.label.setAlignment(QtCore.Qt.AlignCenter)
        self.label.setObjectName("label")
        self.verticalLayout_7.addWidget(self.label)
        self.comboBox = QtWidgets.QComboBox(self.centralwidget)
        # the style sheet of the second combobox
        self.comboBox.setStyleSheet(
                "QComboBox QAbstractItemView" "{"
                "font:32px;"
                "color: #FFFFFF"

                "}"
                
                "QComboBox QAbstractItemView" "{"
    "font:32px;"
        "color: #FFFFFF"
    
"}"
                "QComboBox:hover {\n"
"     color: #FFFFFF; background-color: rgb(0,143,150);\n"
"}\n"                                 
"QComboBox:pressed {    \n"
"   color: #FFFFFF;  background-color: rgb(0,143,150);\n"
"}\n")
        self.comboBox.setObjectName("comboBox")
        self.verticalLayout_7.addWidget(self.comboBox)
        self.horizontalLayout_7.addLayout(self.verticalLayout_7)
        self.verticalLayout_6.addLayout(self.horizontalLayout_7)
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.verticalLayout_9 = QtWidgets.QVBoxLayout()
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)

        # define our widgets
        self.combo2 = self.comboBox
        self.combo1 = self.comboBox_2

        # Add items to the combobox
        self.combo1.currentTextChanged.connect(self._updateCombo2)
        self.combo1.addItems(("uninformed search", "informed search"))
        # show what the user chose after the second dropdown)
        self.combo2.activated.connect(self.clicker2)



        self.label_3.setFont(font)
        self.label_3.setStyleSheet("color: #232f34")
        self.label_3.setObjectName("label_3")
        self.verticalLayout_9.addWidget(self.label_3)
        self.NodesList = QtWidgets.QTextEdit(self.centralwidget)
        self.NodesList.setMaximumSize(QtCore.QSize(16777215, 50))
        self.NodesList.setObjectName("NodesList")
        self.verticalLayout_9.addWidget(self.NodesList)
        self.label_9 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(False)
        font.setWeight(50)
        self.label_9.setFont(font)
        self.label_9.setStyleSheet("color:#232f34")
        self.label_9.setObjectName("label_9")
        self.verticalLayout_9.addWidget(self.label_9)
        self.WeightsList = QtWidgets.QTextEdit(self.centralwidget)
        self.WeightsList.setMaximumSize(QtCore.QSize(16777215, 50))
        self.WeightsList.setObjectName("WeightsList")
        self.verticalLayout_9.addWidget(self.WeightsList)
        self.label_12 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_12.setFont(font)
        self.label_12.setStyleSheet("color: #232f34")
        self.label_12.setObjectName("label_12")
        self.verticalLayout_9.addWidget(self.label_12)
        self.Heuristic = QtWidgets.QTextEdit(self.centralwidget)
        self.Heuristic.setMaximumSize(QtCore.QSize(16777215, 200))
        self.Heuristic.setObjectName("Heuristic")
        self.verticalLayout_9.addWidget(self.Heuristic)
        self.horizontalLayout_8.addLayout(self.verticalLayout_9)
        self.verticalLayout_10 = QtWidgets.QVBoxLayout()
        self.verticalLayout_10.setObjectName("verticalLayout_10")
        self.checkBox = QtWidgets.QCheckBox(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.checkBox.setFont(font)
        self.checkBox.setStyleSheet("color: #000000")
        self.checkBox.setObjectName("checkBox")
        self.verticalLayout_10.addWidget(self.checkBox)
        self.label_5 = QtWidgets.QLabel(self.centralwidget)
        self.label_5.setMinimumSize(QtCore.QSize(365, 0))
        self.label_5.setMaximumSize(QtCore.QSize(334, 47))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_5.setFont(font)
        self.label_5.setStyleSheet("color: #232f34")
        self.label_5.setAlignment(QtCore.Qt.AlignCenter)
        self.label_5.setObjectName("label_5")
        self.verticalLayout_10.addWidget(self.label_5)
        self.GraphDict = QtWidgets.QTextEdit(self.centralwidget)
        self.GraphDict.setMaximumSize(QtCore.QSize(10000, 500))
        self.GraphDict.setObjectName("GraphDict")
        self.verticalLayout_10.addWidget(self.GraphDict)
        self.horizontalLayout_8.addLayout(self.verticalLayout_10)
        self.verticalLayout_11 = QtWidgets.QVBoxLayout()
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.label_10 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_10.setFont(font)
        self.label_10.setStyleSheet("color:#232f34")
        self.label_10.setObjectName("label_10")
        self.verticalLayout_11.addWidget(self.label_10)
        self.InitialNode = QtWidgets.QTextEdit(self.centralwidget)
        self.InitialNode.setMaximumSize(QtCore.QSize(16777215, 50))
        self.InitialNode.setObjectName("InitialNode")
        self.verticalLayout_11.addWidget(self.InitialNode)
        self.label_11 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_11.setFont(font)
        self.label_11.setStyleSheet("color:#232f34")
        self.label_11.setObjectName("label_11")
        self.verticalLayout_11.addWidget(self.label_11)
        self.GoalNode = QtWidgets.QTextEdit(self.centralwidget)
        self.GoalNode.setMaximumSize(QtCore.QSize(16777215, 50))
        self.GoalNode.setObjectName("GoalNode")
        self.verticalLayout_11.addWidget(self.GoalNode)
        self.label_13 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_13.setFont(font)
        self.label_13.setStyleSheet("color: #232f34")
        self.label_13.setObjectName("label_13")
        self.verticalLayout_11.addWidget(self.label_13)
        self.MaxDepth = QtWidgets.QTextEdit(self.centralwidget)
        self.MaxDepth.setMaximumSize(QtCore.QSize(16777215, 50))
        self.MaxDepth.setObjectName("MaxDepth")
        self.verticalLayout_11.addWidget(self.MaxDepth)
        self.label_14 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_14.setFont(font)
        self.label_14.setStyleSheet("color: #232f34")
        self.label_14.setObjectName("label_14")
        self.verticalLayout_11.addWidget(self.label_14)
        self.iterations = QtWidgets.QTextEdit(self.centralwidget)
        self.iterations.setObjectName("iterations")
        self.verticalLayout_11.addWidget(self.iterations)
        self.horizontalLayout_8.addLayout(self.verticalLayout_11)
        self.verticalLayout_6.addLayout(self.horizontalLayout_8)
        self.verticalLayout.addLayout(self.verticalLayout_6)
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.pushButton.setFont(font)

        # the style sheet of the start button
        self.pushButton.setStyleSheet("QPushButton\n"
"{\n"
"   color:white;\n"
"}\n"
"QPushButton:hover {\n"
"    background-color: rgb(0,143,150);\n"
"}\n"
"\n"
"QPushButton:pressed {    \n"
"    background-color: rgb(51,51,51);\n"
"}\n"
"")
        self.pushButton.setObjectName("pushButton")
        self.verticalLayout.addWidget(self.pushButton)
        self.label_8 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        self.label_8.setFont(font)
        self.label_8.setStyleSheet("color: #00a8a8")
        self.label_8.setObjectName("label_8")
        self.verticalLayout.addWidget(self.label_8)
        self.DisplayResult = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.DisplayResult.setMaximumSize(QtCore.QSize(16777215, 80))
        self.DisplayResult.setObjectName("DisplayResult")
        self.verticalLayout.addWidget(self.DisplayResult)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.verticalLayout_12 = QtWidgets.QVBoxLayout()
        self.verticalLayout_12.setObjectName("verticalLayout_12")
        self.label_6 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label_6.setFont(font)
        self.label_6.setStyleSheet("color: #232f34")
        self.label_6.setObjectName("label_6")
        self.verticalLayout_12.addWidget(self.label_6)
        self.horizontalLayout_6.addLayout(self.verticalLayout_12)
        self.verticalLayout_13 = QtWidgets.QVBoxLayout()
        self.verticalLayout_13.setObjectName("verticalLayout_13")
        self.label_7 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label_7.setFont(font)
        self.label_7.setStyleSheet("color: #232f34")
        self.label_7.setObjectName("label_7")
        self.label_7.setMaximumSize(QtCore.QSize(0, 6000))
        self.verticalLayout_13.addWidget(self.label_7)

        # making the figure that will be at the canvas showing the output solution
        self.figure2 = plt.figure(2)
        self.canvas2 = FigureCanvas(self.figure2)
        self.verticalLayout_12.addWidget(self.canvas2)



        self.horizontalLayout_6.addLayout(self.verticalLayout_13)
        self.verticalLayout.addLayout(self.horizontalLayout_6)
        self.horizontalLayout_9.addLayout(self.verticalLayout)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        # changing the label of result
        self.comboBox_2.currentTextChanged['QString'].connect(self.comboBox.setCurrentText)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Search Algorithm Visualizer"))
        self.label_2.setText(_translate("MainWindow", "Choose Search Type"))
        self.label.setText(_translate("MainWindow", "Choose Search Algorithm"))
        self.label_3.setText(_translate("MainWindow", "Enter the nodes with spaces between them"))
        self.label_9.setText(_translate("MainWindow", "Enter Weights of edges with spaces & order of edges"))
        self.label_12.setText(_translate("MainWindow", "Heuristic function in dictionary form, if greedy or A*"))
        self.label_5.setText(_translate("MainWindow", "Enter graph in the form of dictionary"))
        self.label_10.setText(_translate("MainWindow", "Enter your initial node  "))
        self.label_11.setText(_translate("MainWindow", "Enter your goal node(s)"))
        self.label_13.setText(_translate("MainWindow", "Enter maximum depth, if depth limited "))
        self.label_14.setText(_translate("MainWindow", "Enter number of Graph levels, if iterative depth "))
        self.checkBox.setText(_translate("MainWindow", "Is your graph directed ?"))
        self.pushButton.setText(_translate("MainWindow", "Start"))
        self.label_8.setText(_translate("MainWindow", "Results"))
        self.label_6.setText(_translate("MainWindow", "Graph with solution path highlighted in green & initial and goal node in red"))
        self.label_7.setText(_translate("MainWindow", "The Graph With Solution Path Highlighted"))

        # setting the handler function to start button
        self.pushButton.clicked.connect(self.start)

    # the function that decide what algorithms to show based on the type of search selected in combobox 1
    def _updateCombo2(self, text):
            self.combo2.clear()
            if text == "uninformed search":
                    self.combo2.addItems(
                            ("Breadth first search", "Depth first search", "Depth limited search","Iterative deepning search", "Uniform cost search"))
            elif text == "informed search":
                    self.combo2.addItems(("A* search", "Greedy search"))

    # the handler function that adds the selected searching algorithm from the combobox to the result label
    def clicker2(self):
            self.label_8.setText(f'Results will be shown using: {self.combo1.currentText()} - {self.combo2.currentText()}')


    # def plotinput(self, inputedges, nodes, GoalNode, InitialNode):
    #     self.figure2.clf()
    #     color_map = []
    #     B = nx.DiGraph()
    #     B.add_edges_from(inputedges, color='black')
    #     Pos = nx.fruchterman_reingold_layout(B)
    #     for i in nodes:
    #         if (i in GoalNode):
    #             color_map.append('blue')
    #         elif (i in InitialNode):
    #             color_map.append('blue')
    #         else:
    #             color_map.append('blue')
    #     print(color_map)
    #     nx.draw_networkx(B, Pos, node_size=200, node_color=color_map, with_labels=True, nodelist=nodes,
    #                      edgelist=inputedges)
    #     nx.draw_networkx_edges(B, Pos, arrowsize=5, edge_color='black', edge_width=2, colorbar=True, edgelist=B.edges())
    #     self.canvas2.draw_idle()

    def plotsol(self, inputedges, nodes,weights ,GoalNodes, InitialNode,solpath, dir):
        self.figure2.clf()
        color_map = []
        soledges= Logic.GetHighlightedEdges(solpath)
        G = nx.DiGraph()
        # G.add_edges_from(inputedges, color='black')
        G.add_edges_from(inputedges)
        Pos = nx.fruchterman_reingold_layout(G)
        for i in nodes:
            if i in solpath:
                color_map.append('red')
            else:
                color_map.append('blue')
        # print(color_map)
        nx.draw_networkx(G, Pos, node_size=200, node_color=color_map, with_labels=True, nodelist=nodes,
                         edgelist=inputedges, arrows=dir)
        # drawing blue normal edges
        nx.draw_networkx_edges(G, Pos, arrowsize=5, with_labels=True, edge_color='b',edge_width=2, colorbar=True,
                               edgelist=inputedges, arrows=dir)
        nx.draw_networkx_edges(G, Pos, arrowsize=5, with_labels=True, edge_color='r', edge_width=2, colorbar=True,
                               edgelist=soledges, arrows=dir)
        # setting the edges weights
        weightlistindex = 0
        for a, b in inputedges:
            G.edges[a, b]['weight'] = weights[weightlistindex]
            weightlistindex += 1

        edge_labels = nx.get_edge_attributes(G, "weight")
        # print(edge_labels)
        nx.draw_networkx_edge_labels(G, Pos, edge_labels)
        nx.draw_networkx_edge_labels(G, Pos, edge_labels=edge_labels, arrows=False)
        # showing the plot in the created canvas
        self.canvas2.draw_idle()

    def drawInputGraph(self,edges, nodes, weights, dir, show_buttons=True,
                       only_physics_buttons=False):
        # creating a graph
        G = nx.DiGraph()
        # make a pyvis network
        pyvis_graph = Network('1000px', '1000px', directed=dir)
        G.add_edges_from(edges, color='black')
        Pos = nx.fruchterman_reingold_layout(G)
        nx.draw_networkx(G, Pos, node_color='blue', with_labels=True, nodelist=nodes, edgelist=edges)
        nx.draw_networkx_edges(G, Pos, arrowsize=5, with_labels=True, edge_color='black', edge_width=2, colorbar=True,
                               edgelist=G.edges())
        # setting the edges weights
        weightlistindex = 0
        for a, b in edges:
            G.edges[a, b]['weight'] = weights[weightlistindex]
            weightlistindex += 1

        edge_labels = nx.get_edge_attributes(G, "weight")
        # print(edge_labels)
        nx.draw_networkx_edge_labels(G, Pos, edge_labels)
        nx.draw_networkx_edge_labels(G, Pos, edge_labels=edge_labels)

        # turn buttons on
        if show_buttons:
            if only_physics_buttons:
                pyvis_graph.show_buttons(filter_=['physics'])
            else:
                pyvis_graph.show_buttons()

        # populates the nodes and edges data structures
        pyvis_graph.from_nx(G)
        pyvis_graph.show('Input Graph.html')



    def start(self):
            g = Graph.Graph()                                               #creating an object from the class graph
            g.GoalNodes = Logic.getNodesList(self.GoalNode.toPlainText())   #setting the goal nodes
            g.InitialNode= self.InitialNode.toPlainText()                   #setting the inital node
            g.graph = Logic.getGraph(self.GraphDict.toPlainText())           #setting the graph dictionary
            g.Nodes = Logic.getNodesList(self.NodesList.toPlainText())        #setting the node list
            g.edges= Logic.getEdgesList(g.graph)                               #setting the edgeslist
            g.EdgesWeights = Logic.getWeightsList(self.WeightsList.toPlainText()) #setting the edges weights
            solpathstr = "the solution path is"                                   #the string that will be used to show the solution path
            visitedstr = "the visited nodes in order are"                            #the string that will be used to show the visited nodes in order
            coststr ="the cost is equal to"+ "  "                                   #the string that will show the cost
            error= " please revise the entered goal nodes and your initial node, make sure those nodes exist in your entered graph"
            res= ''

            if(g.InitialNode in g.Nodes and any(item in g.GoalNodes for item in g.Nodes)):
                if self.checkBox.isChecked():       # if the graph inputed is checked as directed or not
                    g.dir= True                     # set the graph direction to true(directed)
                # The function that draw the input graph in an HTML file
                self.drawInputGraph(g.edges, g.Nodes, g.EdgesWeights, g.dir, show_buttons=True, only_physics_buttons=False)
             #for testing purposes
                # print(g.graph)
                # print(g.Nodes)
                # print(edges)

                # check if the algorithm chosen is Breadth first search
                if (str(self.combo2.currentText()) == "Breadth first search"):
                    g.path, g.visited = Logic.BFS(g.graph, g.InitialNode, g.GoalNodes)
                    so = solpathstr + str(g.path) + "\n"
                    vi = visitedstr + str(g.visited) + "\n"
                    c = Logic.CalcPathCost(g.edges, g.EdgesWeights, g.path)
                    cost = coststr + str(c)
                    res = so + vi + cost
                    self.DisplayResult.setPlainText(res)
                    self.plotsol(g.edges, g.Nodes, g.EdgesWeights, g.GoalNodes, g.InitialNode, g.path, g.dir)

                # check if the algorithm chosen is Depth first search
                if (str(self.combo2.currentText()) == "Depth first search"):
                        self.figure2.clf()
                        g.path, g.visited = Logic.DFS(g.graph,g.InitialNode, g.GoalNodes)
                        so = solpathstr + str(g.path) +"\n"
                        vi= visitedstr + str(g.visited)+ "\n"
                        c= Logic.CalcPathCost(g.edges,g.EdgesWeights,g.path)
                        cost= coststr + str(c)
                        res = so + vi + cost
                        self.DisplayResult.setPlainText(res)
                        # self.plotinput(g.edges,g.Nodes,g.GoalNodes,g.InitialNode)
                        self.plotsol(g.edges, g.Nodes, g.EdgesWeights ,g.GoalNodes, g.InitialNode, g.path, g.dir)


                #check if the algorithm chosen is depth limited search
                if (str(self.combo2.currentText())=="Depth limited search"):
                    g.MaxDepth= int(self.MaxDepth.toPlainText())
                    g.path = Logic.DLS(g.graph,g.InitialNode,g.GoalNodes, Logic.pathlist, 0, g.MaxDepth)
                    if (g.path):
                    # print("Path to goal node available")
                    # print("Path", path)
                        solpathstr ="Path available within maximum limit"+str(g.path) + "\n"
                        c = Logic.CalcPathCost(g.edges, g.EdgesWeights, g.path)
                        cost = coststr + str(c)
                        res = solpathstr + cost
                        self.DisplayResult.setPlainText(res)
                        self.plotsol(g.edges, g.Nodes, g.EdgesWeights, g.GoalNodes, g.InitialNode, g.path, g.dir)
                    else:
                        self.DisplayResult.setPlainText("no path available within specified maximum depth")
                    # print("No path available for the goal node in given depth limit")



                #check if the algorithm chosen is iterative deepning search
                if (str(self.combo2.currentText())=="Iterative deepning search"):
                    g.iterat= int(self.iterations.toPlainText())
                    g.path,i = Logic.IDDLS(g.graph, g.InitialNode, g.GoalNodes, g.iterat)
                    if (g.path):
                        # print("Path to goal node available")
                        # print("Path", path)
                        solpathstr = "Path available within maximum limit" + str(g.path) + " at level number "+str(i)+"\n"
                        c = Logic.CalcPathCost(g.edges, g.EdgesWeights, g.path)
                        cost = coststr + str(c)
                        res = solpathstr + cost
                        self.DisplayResult.setPlainText(res)
                        self.plotsol(g.edges, g.Nodes, g.EdgesWeights, g.GoalNodes, g.InitialNode, g.path, g.dir)
                    else:
                        self.DisplayResult.setPlainText("no path available within levels of graph")



                # check if the algorithm chosen is Uniform cost search
                if (str(self.combo2.currentText()) == "Uniform cost search"):
                    f= Logic.BuildDictWithCost(g.Nodes,g.graph,g.EdgesWeights)
                    p,g.visited= Logic.UniCost(f,g.InitialNode,g.GoalNodes)
                    g.path= Logic.GetSolutionPathAsList(p)
                    so = solpathstr + str(g.path) + "\n"
                    vi = visitedstr + str(g.visited) + "\n"
                    c= Logic.PathCost(p)[0]
                    cost = coststr + str(c)
                    res = so + vi + cost
                    self.DisplayResult.setPlainText(res)
                    self.plotsol(g.edges, g.Nodes,g.EdgesWeights ,g.GoalNodes, g.InitialNode, g.path, g.dir)



                # check if the algorithm chosen is A* search
                if (str(self.combo2.currentText()) == "A* search"):
                    global HeuristicFunctionAstar
                    Logic.HeuristicFunctionAstar=Logic.getGraph(self.Heuristic.toPlainText())
                    # print(HeuristicFunction)
                    f = Logic.BuildDictWithCost(g.Nodes, g.graph, g.EdgesWeights)
                    p, g.visited = Logic.AStar(f, g.InitialNode, g.GoalNodes)
                    # print(f)
                    g.path = Logic.GetSolutionPathAsList(p)
                    so = solpathstr + str(g.path) + "\n"
                    # print(so)
                    vi = visitedstr + str(g.visited) + "\n"
                    # print(vi)
                    c = Logic.PathFCost(p)[0]
                    cost = coststr + str(c)
                    # print(cost)
                    res = so + vi + cost
                    self.DisplayResult.setPlainText(res)
                    self.plotsol(g.edges, g.Nodes,g.EdgesWeights ,g.GoalNodes, g.InitialNode, g.path,g.dir)

                # check if the algorithm chosen is Greedy search
                if (str(self.combo2.currentText()) == "Greedy search"):
                    # global HeuristicFunctionGreedy
                    Logic.HeuristicFunctionGreedy = Logic.getGraph(self.Heuristic.toPlainText())
                    # print(Logic.HeuristicFunctionGreedy)
                    f = Logic.BuildDictWithCost(g.Nodes, g.graph, g.EdgesWeights)
                    p, g.visited = Logic.Greedy(f, g.InitialNode, g.GoalNodes)
                    # print(f)
                    g.path = Logic.GetSolutionPathAsList(p)
                    so = solpathstr + str(g.path) + "\n"
                    # print(so)
                    vi = visitedstr + str(g.visited) + "\n"
                    # print(vi)
                    c = Logic.CalculateSolutionCost(g.path,Logic.HeuristicFunctionGreedy)
                    cost = coststr + str(c)
                    # print(cost)
                    res = so + vi + cost
                    self.DisplayResult.setPlainText(res)
                    self.plotsol(g.edges, g.Nodes, g.EdgesWeights,g.GoalNodes, g.InitialNode, g.path, g.dir)
                # if invalid inputs will show this message
            else: self.DisplayResult.setPlainText(error)






if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())

